(* This file has been autogenerated by mir-crunch *)
module Internal = struct
let file_chunks = function
 | "prettify.js" | "/prettify.js" -> Some ["// Copyright (C) 2006 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * @fileoverview\n * some functions for browser-side pretty printing of code contained in html.\n *\n * <p>\n * For a fairly comprehensive set of languages see the\n * <a href=\"http://google-code-prettify.googlecode.com/svn/trunk/README.html#langs\">README</a>\n * file that came with this source.  At a minimum, the lexer should work on a\n * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n * and a subset of Perl, but, because of commenting conventions, doesn't work on\n * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n * <p>\n * Usage: <ol>\n * <li> include this source file in an html page via\n *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n * <li> define style rules.  See the example page for examples.\n * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\n *    {@code class=prettyprint.}\n *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\n *    printer needs to do more substantial DOM manipulations to support that, so\n *    some css styles may not be preserved.\n * </ol>\n * That's it.  I wanted to keep the API as simple as possible, so there's no\n * need to specify which language the code is in, but if you wish, you can add\n * another class to the {@code <pre>} or {@code <code>} element to specify the\n * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\n * starts with \"lang-\" followed by a file extension, specifies the file type.\n * See the \"lang-*.js\" files in this directory for code that implements\n * per-language file handlers.\n * <p>\n * Change log:<br>\n * cbeust, 2006/08/22\n * <blockquote>\n *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n * </blockquote>\n * @requires console\n */\n\n// JSLint declarations\n/*global console, document, navigator, setTimeout, window */\n\n/**\n * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\n * UI events.\n * If set to {@code false}, {@code prettyPrint()} is synchronous.\n */\nwindow['PR_SHOULD_USE_CONTINUATION'] = true;\n\n/** the number of characters between tab columns */\nwindow['PR_TAB_WIDTH'] = 8;\n\n/** Contains functions for creating and registering new language handlers.\n  * @type {Object}\n  */\nwindow['PR']\n\n/** Pretty print a chunk of code.\n  *\n  * @param {string} sourceCodeHtml code as html\n  * @return {string} code as html, but prettier\n  */\n  = window['prettyPrintOne']\n/** Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n  * {@code class=prettyprint} and prettify them.\n  * @param {Function?} opt_whenDone if specified, called when the last entry\n  *     has been finished.\n  */\n  = window['prettyPrint'] = void 0;\n\n\n(function () {\n  // Keyword lists for various languages.\n  var FLOW_CONTROL_KEYWORDS =\n      \"break continue do else for if while \"; /* return */\n  var C_KEYWORDS = FLOW_CONTROL_KEYWORDS + \"auto case char const default \" +\n      \"double enum extern float goto int long register short signed sizeof \" +\n      \"static struct switch typedef union unsigned void volatile \";\n  var COMMON_KEYWORDS = C_KEYWORDS + \"catch class delete false import \" +\n      \"new operator private protected public this throw true try typeof \";\n  var CPP_KEYWORDS = COMMON_KEYWORDS + \"alignof align_union asm axiom bool \" +\n      \"concept concept_map const_cast constexpr decltype \" +\n      \"dynamic_cast explicit export f";
"riend inline late_check \" +\n      \"mutable namespace nullptr reinterpret_cast static_assert static_cast \" +\n      \"template typeid typename using virtual wchar_t where \";\n  var JAVA_KEYWORDS = COMMON_KEYWORDS +\n      \"abstract boolean byte extends final finally implements import \" +\n      \"instanceof null native package strictfp super synchronized throws \" +\n      \"transient \";\n  var CSHARP_KEYWORDS = JAVA_KEYWORDS +\n      \"as base by checked decimal delegate descending dynamic event \" +\n      \"fixed foreach from group implicit in interface internal into is lock \" +\n      \"object out override orderby params partial readonly ref sbyte sealed \" +\n      \"stackalloc string select uint ulong unchecked unsafe ushort var \";\n  var COFFEE_KEYWORDS = \"all and by catch class else extends false finally \" +\n      \"for if in is isnt loop new no not null of off on or super then \" + /* return */\n      \"true try unless until when while yes \";\n  var JSCRIPT_KEYWORDS = COMMON_KEYWORDS +\n      \"debugger eval export function get null set undefined var with \" +\n      \"Infinity NaN \";\n  var OCAML_KEYWORDS = \"let match_lwt for_lwt while_lwt lwt open with match and type class module begin end \" +\n      \"function fun for if else class constraint type include inherit method mutable \" +\n      \"or true then val when with while\";\n  var PERL_KEYWORDS = \"caller delete die do dump elsif eval exit foreach for \" +\n      \"goto if import last local my next no our print package redo require \" +\n      \"sub undef unless until use wantarray while BEGIN END \";\n  var PYTHON_KEYWORDS = FLOW_CONTROL_KEYWORDS + \"and as assert class def del \" +\n      \"elif except exec finally from global import in is lambda \" +\n      \"nonlocal not or pass print raise try with yield \" +\n      \"False True None \";\n  var RUBY_KEYWORDS = FLOW_CONTROL_KEYWORDS + \"alias and begin case class def\" +\n      \" defined elsif end ensure false in module next nil not or redo rescue \" +\n      \"retry self super then true undef unless until when yield BEGIN END \";\n  var SH_KEYWORDS = FLOW_CONTROL_KEYWORDS + \"case done elif esac eval fi \" +\n      \"function in local set then until \";\n  var ALL_KEYWORDS = ( OCAML_KEYWORDS );\n//      CPP_KEYWORDS + CSHARP_KEYWORDS + JSCRIPT_KEYWORDS + OCAML_KEYWORDS +\n//      PERL_KEYWORDS + PYTHON_KEYWORDS + RUBY_KEYWORDS + SH_KEYWORDS);\n\n  // token style names.  correspond to css classes\n  /** token style for a string literal */\n  var PR_STRING = 'str';\n  /** token style for a keyword */\n  var PR_KEYWORD = 'kwd';\n  /** token style for a comment */\n  var PR_COMMENT = 'com';\n  /** token style for a type */\n  var PR_TYPE = 'typ';\n  /** token style for a literal value.  e.g. 1, null, true. */\n  var PR_LITERAL = 'lit';\n  /** token style for a punctuation string. */\n  var PR_PUNCTUATION = 'pun';\n  /** token style for a punctuation string. */\n  var PR_PLAIN = 'pln';\n\n  /** token style for an sgml tag. */\n  var PR_TAG = 'tag';\n  /** token style for a markup declaration such as a DOCTYPE. */\n  var PR_DECLARATION = 'dec';\n  /** token style for embedded source. */\n  var PR_SOURCE = 'src';\n  /** token style for an sgml attribute name. */\n  var PR_ATTRIB_NAME = 'atn';\n  /** token style for an sgml attribute value. */\n  var PR_ATTRIB_VALUE = 'atv';\n\n  /**\n   * A class that indicates a section of markup that is not code, e.g. to allow\n   * embedding of line numbers within code listings.\n   */\n  var PR_NOCODE = 'nocode';\n\n  /** A set of tokens that can precede a regular expression literal in\n    * javascript.\n    * http://www.mozilla.org/js/language/js20/rationale/syntax.html has the full\n    * list, but I've removed ones that might be problematic when seen in\n    * languages that don't support regular expression literals.\n    *\n    * <p>Specifically, I've removed any keywords that can't precede a regexp\n    * literal in a syntactically legal javascript program, and I've removed the\n    * \"in\" keyword since it's not a keyword in many languages, and might be used\n    * as a count of inches.\n    *\n    * <p>The link a above does not accurately describe EcmaScript rules since\n    * it fails";
" to distinguish between (a=++/b/i) and (a++/b/i) but it works\n    * very well in practice.\n    *\n    * @private\n    */\n  var REGEXP_PRECEDER_PATTERN = function () {\n      var preceders = [\n          \"!\", \"!=\", \"!==\", \"#\", \"%\", \"%=\", \"&\", \"&&\", \"&&=\",\n          \"&=\", \"(\", \"*\", \"*=\", /* \"+\", */ \"+=\", \",\", /* \"-\", */ \"-=\",\n          \"->\", /*\".\", \"..\", \"...\", handled below */ \"/\", \"/=\", \":\", \"::\", \";\",\n          \"<\", \"<<\", \"<<=\", \"<=\", \"=\", \"==\", \"===\", \">\",\n          \">=\", \">>\", \">>=\", \">>>\", \">>>=\", \"?\", \"@\", \"[\",\n          \"^\", \"^=\", \"^^\", \"^^=\", \"{\", \"|\", \"|=\", \"||\",\n          \"||=\", \"~\" /* handles =~ and !~ */,\n          \"break\", \"case\", \"continue\", \"delete\",\n          \"do\", \"else\", \"finally\", \"instanceof\",\n          /* \"return\",*/ \"throw\", \"try\", \"typeof\"\n          ];\n      var pattern = '(?:^^|[+-]';\n      for (var i = 0; i < preceders.length; ++i) {\n        pattern += '|' + preceders[i].replace(/([^=<>:&a-z])/g, '\\\\$1');\n      }\n      pattern += ')\\\\s*';  // matches at end, and matches empty string\n      return pattern;\n      // CAVEAT: this does not properly handle the case where a regular\n      // expression immediately follows another since a regular expression may\n      // have flags for case-sensitivity and the like.  Having regexp tokens\n      // adjacent is not valid in any language I'm aware of, so I'm punting.\n      // TODO: maybe style special characters inside a regexp as punctuation.\n    }();\n\n  \n  /**\n   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\n   * matches the union of the sets of strings matched by the input RegExp.\n   * Since it matches globally, if the input strings have a start-of-input\n   * anchor (/^.../), it is ignored for the purposes of unioning.\n   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\n   * @return {RegExp} a global regex.\n   */\n  function combinePrefixPatterns(regexs) {\n    var capturedGroupIndex = 0;\n  \n    var needToFoldCase = false;\n    var ignoreCase = false;\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.ignoreCase) {\n        ignoreCase = true;\n      } else if (/[a-z]/i.test(regex.source.replace(\n                     /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\n        needToFoldCase = true;\n        ignoreCase = false;\n        break;\n      }\n    }\n  \n    function decodeEscape(charsetPart) {\n      if (charsetPart.charAt(0) !== '\\\\') { return charsetPart.charCodeAt(0); }\n      switch (charsetPart.charAt(1)) {\n        case 'b': return 8;\n        case 't': return 9;\n        case 'n': return 0xa;\n        case 'v': return 0xb;\n        case 'f': return 0xc;\n        case 'r': return 0xd;\n        case 'u': case 'x':\n          return parseInt(charsetPart.substring(2), 16)\n              || charsetPart.charCodeAt(1);\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7':\n          return parseInt(charsetPart.substring(1), 8);\n        default: return charsetPart.charCodeAt(1);\n      }\n    }\n  \n    function encodeEscape(charCode) {\n      if (charCode < 0x20) {\n        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n      }\n      var ch = String.fromCharCode(charCode);\n      if (ch === '\\\\' || ch === '-' || ch === '[' || ch === ']') {\n        ch = '\\\\' + ch;\n      }\n      return ch;\n    }\n  \n    function caseFoldCharset(charSet) {\n      var charsetParts = charSet.substring(1, charSet.length - 1).match(\n          new RegExp(\n              '\\\\\\\\u[0-9A-Fa-f]{4}'\n              + '|\\\\\\\\x[0-9A-Fa-f]{2}'\n              + '|\\\\\\\\[0-3][0-7]{0,2}'\n              + '|\\\\\\\\[0-7]{1,2}'\n              + '|\\\\\\\\[\\\\s\\\\S]'\n              + '|-'\n              + '|[^-\\\\\\\\]',\n              'g'));\n      var groups = [];\n      var ranges = [];\n      var inverse = charsetParts[0] === '^';\n      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\n        var p = charsetParts[i];\n        switch (p) {\n          case '\\\\B': case '\\\\b':\n          case '\\\\D': case '\\\\d':\n          case '\\\\S': case '\\\\s':\n          case '\\\\W': case '\\\\w':\n      ";
"      groups.push(p);\n            continue;\n        }\n        var start = decodeEscape(p);\n        var end;\n        if (i + 2 < n && '-' === charsetParts[i + 1]) {\n          end = decodeEscape(charsetParts[i + 2]);\n          i += 2;\n        } else {\n          end = start;\n        }\n        ranges.push([start, end]);\n        // If the range might intersect letters, then expand it.\n        if (!(end < 65 || start > 122)) {\n          if (!(end < 65 || start > 90)) {\n            ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n          }\n          if (!(end < 97 || start > 122)) {\n            ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n          }\n        }\n      }\n  \n      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n      // -> [[1, 12], [14, 14], [16, 17]]\n      ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });\n      var consolidatedRanges = [];\n      var lastRange = [NaN, NaN];\n      for (var i = 0; i < ranges.length; ++i) {\n        var range = ranges[i];\n        if (range[0] <= lastRange[1] + 1) {\n          lastRange[1] = Math.max(lastRange[1], range[1]);\n        } else {\n          consolidatedRanges.push(lastRange = range);\n        }\n      }\n  \n      var out = ['['];\n      if (inverse) { out.push('^'); }\n      out.push.apply(out, groups);\n      for (var i = 0; i < consolidatedRanges.length; ++i) {\n        var range = consolidatedRanges[i];\n        out.push(encodeEscape(range[0]));\n        if (range[1] > range[0]) {\n          if (range[1] + 1 > range[0]) { out.push('-'); }\n          out.push(encodeEscape(range[1]));\n        }\n      }\n      out.push(']');\n      return out.join('');\n    }\n  \n    function allowAnywhereFoldCaseAndRenumberGroups(regex) {\n      // Split into character sets, escape sequences, punctuation strings\n      // like ('(', '(?:', ')', '^'), and runs of characters that do not\n      // include any of the above.\n      var parts = regex.source.match(\n          new RegExp(\n              '(?:'\n              + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\n              + '|\\\\\\\\u[A-Fa-f0-9]{4}'  // a unicode escape\n              + '|\\\\\\\\x[A-Fa-f0-9]{2}'  // a hex escape\n              + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\n              + '|\\\\\\\\[^ux0-9]'  // other escape sequence\n              + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\n              + '|[\\\\(\\\\)\\\\^]'  // start/emd of a group, or line start\n              + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\n              + ')',\n              'g'));\n      var n = parts.length;\n  \n      // Maps captured group numbers to the number they will occupy in\n      // the output or to -1 if that has not been determined, or to\n      // undefined if they need not be capturing in the output.\n      var capturedGroups = [];\n  \n      // Walk over and identify back references to build the capturedGroups\n      // mapping.\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          // groups are 1-indexed, so max group index is count of '('\n          ++groupIndex;\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue && decimalValue <= groupIndex) {\n            capturedGroups[decimalValue] = -1;\n          }\n        }\n      }\n  \n      // Renumber groups and reduce capturing groups to non-capturing groups\n      // where possible.\n      for (var i = 1; i < capturedGroups.length; ++i) {\n        if (-1 === capturedGroups[i]) {\n          capturedGroups[i] = ++capturedGroupIndex;\n        }\n      }\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          ++groupIndex;\n          if (capturedGroups[groupIndex] === undefined) {\n            parts[i] = '(?:';\n          }\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue && decimalValue <= groupIndex) {\n            parts[i] = '\\\\' + capturedGroups[groupIndex];\n          }\n      ";
"  }\n      }\n  \n      // Remove any prefix anchors so that the output will match anywhere.\n      // ^^ really does mean an anchored match though.\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }\n      }\n  \n      // Expand letters to groups to handle mixing of case-sensitive and\n      // case-insensitive patterns if necessary.\n      if (regex.ignoreCase && needToFoldCase) {\n        for (var i = 0; i < n; ++i) {\n          var p = parts[i];\n          var ch0 = p.charAt(0);\n          if (p.length >= 2 && ch0 === '[') {\n            parts[i] = caseFoldCharset(p);\n          } else if (ch0 !== '\\\\') {\n            // TODO: handle letters in numeric escapes.\n            parts[i] = p.replace(\n                /[a-zA-Z]/g,\n                function (ch) {\n                  var cc = ch.charCodeAt(0);\n                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n                });\n          }\n        }\n      }\n  \n      return parts.join('');\n    }\n  \n    var rewritten = [];\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.global || regex.multiline) { throw new Error('' + regex); }\n      rewritten.push(\n          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n    }\n  \n    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n  }\n\n\n  /**\n   * Split markup into a string of source code and an array mapping ranges in\n   * that string to the text nodes in which they appear.\n   *\n   * <p>\n   * The HTML DOM structure:</p>\n   * <pre>\n   * (Element   \"p\"\n   *   (Element \"b\"\n   *     (Text  \"print \"))       ; #1\n   *   (Text    \"'Hello '\")      ; #2\n   *   (Element \"br\")            ; #3\n   *   (Text    \"  + 'World';\")) ; #4\n   * </pre>\n   * <p>\n   * corresponds to the HTML\n   * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n   *\n   * <p>\n   * It will produce the output:</p>\n   * <pre>\n   * {\n   *   source: \"print 'Hello '\\n  + 'World';\",\n   *   //                 1         2\n   *   //       012345678901234 5678901234567\n   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n   * }\n   * </pre>\n   * <p>\n   * where #1 is a reference to the {@code \"print \"} text node above, and so\n   * on for the other text nodes.\n   * </p>\n   *\n   * <p>\n   * The {@code} spans array is an array of pairs.  Even elements are the start\n   * indices of substrings, and odd elements are the text nodes (or BR elements)\n   * that contain the text for those substrings.\n   * Substrings continue until the next index or the end of the source.\n   * </p>\n   *\n   * @param {Node} node an HTML DOM subtree containing source-code.\n   * @return {Object} source code and the text nodes in which they occur.\n   */\n  function extractSourceSpans(node) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n  \n    var chunks = [];\n    var length = 0;\n    var spans = [];\n    var k = 0;\n  \n    var whitespace;\n    if (node.currentStyle) {\n      whitespace = node.currentStyle.whiteSpace;\n    } else if (window.getComputedStyle) {\n      whitespace = document.defaultView.getComputedStyle(node, null)\n          .getPropertyValue('white-space');\n    }\n    var isPreformatted = whitespace && 'pre' === whitespace.substring(0, 3);\n  \n    function walk(node) {\n      switch (node.nodeType) {\n        case 1:  // Element\n          if (nocode.test(node.className)) { return; }\n          for (var child = node.firstChild; child; child = child.nextSibling) {\n            walk(child);\n          }\n          var nodeName = node.nodeName;\n          if ('BR' === nodeName || 'LI' === nodeName) {\n            chunks[k] = '\\n';\n            spans[k << 1] = length++;\n            spans[(k++ << 1) | 1] = node;\n          }\n          break;\n        case 3: case 4:  // Text\n          var text = node.nodeValue;\n          if (text.length) {\n            if (!isPreformatted) {\n              text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n            } else {\n              text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\n            }\n            // TODO: handle tabs here?\n       ";
"     chunks[k] = text;\n            spans[k << 1] = length;\n            length += text.length;\n            spans[(k++ << 1) | 1] = node;\n          }\n          break;\n      }\n    }\n  \n    walk(node);\n  \n    return {\n      source: chunks.join('').replace(/\\n$/, ''),\n      spans: spans\n    };\n  }\n\n\n  /**\n   * Apply the given language handler to sourceCode and add the resulting\n   * decorations to out.\n   * @param {number} basePos the index of sourceCode within the chunk of source\n   *    whose decorations are already present on out.\n   */\n  function appendDecorations(basePos, sourceCode, langHandler, out) {\n    if (!sourceCode) { return; }\n    var job = {\n      source: sourceCode,\n      basePos: basePos\n    };\n    langHandler(job);\n    out.push.apply(out, job.decorations);\n  }\n\n  /** Given triples of [style, pattern, context] returns a lexing function,\n    * The lexing function interprets the patterns to find token boundaries and\n    * returns a decoration list of the form\n    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n    * where index_n is an index into the sourceCode, and style_n is a style\n    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n    * all characters in sourceCode[index_n-1:index_n].\n    *\n    * The stylePatterns is a list whose elements have the form\n    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n    *\n    * Style is a style constant like PR_PLAIN, or can be a string of the\n    * form 'lang-FOO', where FOO is a language extension describing the\n    * language of the portion of the token in $1 after pattern executes.\n    * E.g., if style is 'lang-lisp', and group 1 contains the text\n    * '(hello (world))', then that portion of the token will be passed to the\n    * registered lisp handler for formatting.\n    * The text before and after group 1 will be restyled using this decorator\n    * so decorators should take care that this doesn't result in infinite\n    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n    * '<script>foo()<\\/script>', which would cause the current decorator to\n    * be called with '<script>' which would not match the same rule since\n    * group 1 must not be empty, so it would be instead styled as PR_TAG by\n    * the generic tag rule.  The handler registered for the 'js' extension would\n    * then be called with 'foo()', and finally, the current decorator would\n    * be called with '<\\/script>' which would not match the original rule and\n    * so the generic tag rule would identify it as a tag.\n    *\n    * Pattern must only match prefixes, and if it matches a prefix, then that\n    * match is considered a token with the same style.\n    *\n    * Context is applied to the last non-whitespace, non-comment token\n    * recognized.\n    *\n    * Shortcut is an optional string of characters, any of which, if the first\n    * character, gurantee that this pattern and only this pattern matches.\n    *\n    * @param {Array} shortcutStylePatterns patterns that always start with\n    *   a known character.  Must have a shortcut string.\n    * @param {Array} fallthroughStylePatterns patterns that will be tried in\n    *   order if the shortcut ones fail.  May have shortcuts.\n    *\n    * @return {function (Object)} a\n    *   function that takes source code and returns a list of decorations.\n    */\n  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n    var shortcuts = {};\n    var tokenizer;\n    (function () {\n      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n      var allRegexs = [];\n      var regexKeys = {};\n      for (var i = 0, n = allPatterns.length; i < n; ++i) {\n        var patternParts = allPatterns[i];\n        var shortcutChars = patternParts[3];\n        if (shortcutChars) {\n          for (var c = shortcutChars.length; --c >= 0;) {\n            shortcuts[shortcutChars.charAt(c)] = patternParts;\n          }\n        }\n        var regex = patternParts[1];\n        var k = '' + regex;";
"\n        if (!regexKeys.hasOwnProperty(k)) {\n          allRegexs.push(regex);\n          regexKeys[k] = null;\n        }\n      }\n      allRegexs.push(/[\\0-\\uffff]/);\n      tokenizer = combinePrefixPatterns(allRegexs);\n    })();\n\n    var nPatterns = fallthroughStylePatterns.length;\n    var notWs = /\\S/;\n\n    /**\n     * Lexes job.source and produces an output array job.decorations of style\n     * classes preceded by the position at which they start in job.source in\n     * order.\n     *\n     * @param {Object} job an object like {@code\n     *    source: {string} sourceText plain text,\n     *    basePos: {int} position of job.source in the larger chunk of\n     *        sourceCode.\n     * }\n     */\n    var decorate = function (job) {\n      var sourceCode = job.source, basePos = job.basePos;\n      /** Even entries are positions in source in ascending order.  Odd enties\n        * are style markers (e.g., PR_COMMENT) that run from that position until\n        * the end.\n        * @type {Array.<number|string>}\n        */\n      var decorations = [basePos, PR_PLAIN];\n      var pos = 0;  // index into sourceCode\n      var tokens = sourceCode.match(tokenizer) || [];\n      var styleCache = {};\n\n      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n        var token = tokens[ti];\n        var style = styleCache[token];\n        var match = void 0;\n\n        var isEmbedded;\n        if (typeof style === 'string') {\n          isEmbedded = false;\n        } else {\n          var patternParts = shortcuts[token.charAt(0)];\n          if (patternParts) {\n            match = token.match(patternParts[1]);\n            style = patternParts[0];\n          } else {\n            for (var i = 0; i < nPatterns; ++i) {\n              patternParts = fallthroughStylePatterns[i];\n              match = token.match(patternParts[1]);\n              if (match) {\n                style = patternParts[0];\n                break;\n              }\n            }\n\n            if (!match) {  // make sure that we make progress\n              style = PR_PLAIN;\n            }\n          }\n\n          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n          if (isEmbedded && !(match && typeof match[1] === 'string')) {\n            isEmbedded = false;\n            style = PR_SOURCE;\n          }\n\n          if (!isEmbedded) { styleCache[token] = style; }\n        }\n\n        var tokenStart = pos;\n        pos += token.length;\n\n        if (!isEmbedded) {\n          decorations.push(basePos + tokenStart, style);\n        } else {  // Treat group 1 as an embedded block of source code.\n          var embeddedSource = match[1];\n          var embeddedSourceStart = token.indexOf(embeddedSource);\n          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n          if (match[2]) {\n            // If embeddedSource can be blank, then it would match at the\n            // beginning which would cause us to infinitely recurse on the\n            // entire token, so we catch the right context in match[2].\n            embeddedSourceEnd = token.length - match[2].length;\n            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n          }\n          var lang = style.substring(5);\n          // Decorate the left of the embedded source\n          appendDecorations(\n              basePos + tokenStart,\n              token.substring(0, embeddedSourceStart),\n              decorate, decorations);\n          // Decorate the embedded source\n          appendDecorations(\n              basePos + tokenStart + embeddedSourceStart,\n              embeddedSource,\n              langHandlerForExtension(lang, embeddedSource),\n              decorations);\n          // Decorate the right of the embedded section\n          appendDecorations(\n              basePos + tokenStart + embeddedSourceEnd,\n              token.substring(embeddedSourceEnd),\n              decorate, decorations);\n        }\n      }\n      job.decorations = decorations;\n    };\n    return decorate;\n  }\n\n  /** returns a function that produces a list of decorations from source text.\n    *\n    * This code trea";
"ts \" and ' as string delimiters, and \\ as a string\n    * escape.  It does not recognize perl's qq() style strings.\n    * It has no special handling for double delimiter escapes as in basic, or\n    * the tripled delimiters used in python, but should work on those regardless\n    * although in those cases a single string literal may be broken up into\n    * multiple adjacent string literals.\n    *\n    * It recognizes C, C++, and shell style comments.\n    *\n    * @param {Object} options a set of optional parameters.\n    * @return {function (Object)} a function that examines the source code\n    *     in the input job and builds the decoration list.\n    */\n  function sourceDecorator(options) {\n    var shortcutStylePatterns = [], fallthroughStylePatterns = [];\n    if (options['tripleQuotedStrings']) {\n      // '''multi-line-string''', 'single-line-string', and double-quoted\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\n           null, '\\'\"']);\n    } else if (options['multiLineStrings']) {\n      // 'multi-line-string', \"multi-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\n           null, '\\'\"']);\n    } else {\n      // 'single-line-string', \"single-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,\n           /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\n           null, '\"\\'']);\n    }\n    if (options['verbatimStrings']) {\n      // verbatim-string-literal production from the C# grammar.  See issue 93.\n      fallthroughStylePatterns.push(\n          [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n    }\n    var hc = options['hashComments'];\n    if (hc) {\n      if (options['cStyleComments']) {\n        if (hc > 1) {  // multiline hash comments\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n        } else {\n          // Stop C preprocessor declarations at an unclosed open comment\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\n               null, '#']);\n        }\n        fallthroughStylePatterns.push(\n            [PR_STRING,\n             /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h|[a-z]\\w*)>/,\n             null]);\n      } else {\n        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n      }\n    }\n    if (options['cStyleComments']) {\n      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n      fallthroughStylePatterns.push(\n          [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n    }\n    if (options['regexLiterals']) {\n      var REGEX_LITERAL = (\n          // A regular expression literal starts with a slash that is\n          // not followed by * or / so that it is not confused with\n          // comments.\n          '/(?=[^/*])'\n          // and then contains any number of raw characters,\n          + '(?:[^/\\\\x5B\\\\x5C]'\n          // escape sequences (\\x5C),\n          +    '|\\\\x5C[\\\\s\\\\S]'\n          // or non-nesting character sets (\\x5B\\x5D);\n          +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D]|\\\\x5C[\\\\s\\\\S])*(?:\\\\x5D|$))+'\n          // finally closed by a /.\n          + '/');\n      fallthroughStylePatterns.push(\n          ['lang-regex',\n           new RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\n           ]);\n    }\n\n    var keywords = options['keywords'].replace(/^\\s+|\\s+$/g, '');\n    if (keywords.length) {\n      fallthroughStylePatterns.push(\n          [PR_KEYWORD,\n           new RegExp('^(?:' + keywords.replace(/\\s+/g, '|') + ')\\\\b'), null]);\n    }\n\n    shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n    fallthroughStylePatterns.push(\n        // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n        [PR_LI";
"TERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_TYPE,        /^@?[A-Z]+[a-z][A-Za-z_$@0-9]*/, null],\n        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_LITERAL,\n         new RegExp(\n             '^(?:'\n             // A hex number\n             + '0x[a-f0-9]+'\n             // or an octal or decimal number,\n             + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n             // possibly in scientific notation\n             + '(?:e[+\\\\-]?\\\\d+)?'\n             + ')'\n             // with an optional modifier like UL for unsigned long\n             + '[a-z]*', 'i'),\n         null, '0123456789'],\n        // Don't treat escaped quotes in bash as starting strings.  See issue 144.\n        [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\n        [PR_PUNCTUATION, /^.[^\\s\\w\\.$@\\'\\\"\\/\\#\\\\]*/, null]);\n\n    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n  }\n\n  var decorateSource = sourceDecorator({\n        'keywords': ALL_KEYWORDS,\n        'hashComments': false,\n        'cStyleComments': true,\n        'multiLineStrings': true,\n        'regexLiterals': true\n      });\n\n  /**\n   * Given a DOM subtree, wraps it in a list, and puts each line into its own\n   * list item.\n   *\n   * @param {Node} node modified in place.  Its content is pulled into an\n   *     HTMLOListElement, and each line is moved into a separate list item.\n   *     This requires cloning elements, so the input might not have unique\n   *     IDs after numbering.\n   */\n  function numberLines(node, opt_startLineNum) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n    var lineBreak = /\\r\\n?|\\n/;\n  \n    var document = node.ownerDocument;\n  \n    var whitespace;\n    if (node.currentStyle) {\n      whitespace = node.currentStyle.whiteSpace;\n    } else if (window.getComputedStyle) {\n      whitespace = document.defaultView.getComputedStyle(node, null)\n          .getPropertyValue('white-space');\n    }\n    // If it's preformatted, then we need to split lines on line breaks\n    // in addition to <BR>s.\n    var isPreformatted = whitespace && 'pre' === whitespace.substring(0, 3);\n  \n    var li = document.createElement('LI');\n    while (node.firstChild) {\n      li.appendChild(node.firstChild);\n    }\n    // An array of lines.  We split below, so this is initialized to one\n    // un-split line.\n    var listItems = [li];\n  \n    function walk(node) {\n      switch (node.nodeType) {\n        case 1:  // Element\n          if (nocode.test(node.className)) { break; }\n          if ('BR' === node.nodeName) {\n            breakAfter(node);\n            // Discard the <BR> since it is now flush against a </LI>.\n            if (node.parentNode) {\n              node.parentNode.removeChild(node);\n            }\n          } else {\n            for (var child = node.firstChild; child; child = child.nextSibling) {\n              walk(child);\n            }\n          }\n          break;\n        case 3: case 4:  // Text\n          if (isPreformatted) {\n            var text = node.nodeValue;\n            var match = text.match(lineBreak);\n            if (match) {\n              var firstLine = text.substring(0, match.index);\n              node.nodeValue = firstLine;\n              var tail = text.substring(match.index + match[0].length);\n              if (tail) {\n                var parent = node.parentNode;\n                parent.insertBefore(\n                    document.createTextNode(tail), node.nextSibling);\n              }\n              breakAfter(node);\n              if (!firstLine) {\n                // Don't leave blank text nodes in the DOM.\n                node.parentNode.removeChild(node);\n              }\n            }\n          }\n          break;\n      }\n    }\n  \n    // Split a line after the given node.\n    function breakAfter(lineEndNode) {\n      // If there's nothing to the right, then we can skip ending the line\n      // here, and move root-wards since splitting just before an end-tag\n      // would require us to create a bunch of empty copies.\n      while (!lineEndNode.nextSibling) {\n        lineEndNode = lineEndNode.parentNode;\n        if (!lineEndNode) { return; }\n";
"      }\n  \n      function breakLeftOf(limit, copy) {\n        // Clone shallowly if this node needs to be on both sides of the break.\n        var rightSide = copy ? limit.cloneNode(false) : limit;\n        var parent = limit.parentNode;\n        if (parent) {\n          // We clone the parent chain.\n          // This helps us resurrect important styling elements that cross lines.\n          // E.g. in <i>Foo<br>Bar</i>\n          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n          var parentClone = breakLeftOf(parent, 1);\n          // Move the clone and everything to the right of the original\n          // onto the cloned parent.\n          var next = limit.nextSibling;\n          parentClone.appendChild(rightSide);\n          for (var sibling = next; sibling; sibling = next) {\n            next = sibling.nextSibling;\n            parentClone.appendChild(sibling);\n          }\n        }\n        return rightSide;\n      }\n  \n      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n  \n      // Walk the parent chain until we reach an unattached LI.\n      for (var parent;\n           // Check nodeType since IE invents document fragments.\n           (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n        copiedListItem = parent;\n      }\n      // Put it on the list of lines for later processing.\n      listItems.push(copiedListItem);\n    }\n  \n    // Split lines while there are lines left to split.\n    for (var i = 0;  // Number of lines that have been split so far.\n         i < listItems.length;  // length updated by breakAfter calls.\n         ++i) {\n      walk(listItems[i]);\n    }\n  \n    // Make sure numeric indices show correctly.\n    if (opt_startLineNum === (opt_startLineNum|0)) {\n      listItems[0].setAttribute('value', opt_startLineNum);\n    }\n  \n    var ol = document.createElement('OL');\n    ol.className = 'linenums';\n    var offset = Math.max(0, ((opt_startLineNum - 1 /* zero index */)) | 0) || 0;\n    for (var i = 0, n = listItems.length; i < n; ++i) {\n      li = listItems[i];\n      // Stick a class on the LIs so that stylesheets can\n      // color odd/even rows, or any other row pattern that\n      // is co-prime with 10.\n      li.className = 'L' + ((i + offset) % 10);\n      if (!li.firstChild) {\n        li.appendChild(document.createTextNode('\\xA0'));\n      }\n      ol.appendChild(li);\n    }\n  \n    node.appendChild(ol);\n  }\n\n  /**\n   * Breaks {@code job.source} around style boundaries in {@code job.decorations}\n   * and modifies {@code job.sourceNode} in place.\n   * @param {Object} job like <pre>{\n   *    source: {string} source as plain text,\n   *    spans: {Array.<number|Node>} alternating span start indices into source\n   *       and the text node or element (e.g. {@code <BR>}) corresponding to that\n   *       span.\n   *    decorations: {Array.<number|string} an array of style classes preceded\n   *       by the position at which they start in job.source in order\n   * }</pre>\n   * @private\n   */\n  function recombineTagsAndDecorations(job) {\n    var isIE = /\\bMSIE\\b/.test(navigator.userAgent);\n    var newlineRe = /\\n/g;\n  \n    var source = job.source;\n    var sourceLength = source.length;\n    // Index into source after the last code-unit recombined.\n    var sourceIndex = 0;\n  \n    var spans = job.spans;\n    var nSpans = spans.length;\n    // Index into spans after the last span which ends at or before sourceIndex.\n    var spanIndex = 0;\n  \n    var decorations = job.decorations;\n    var nDecorations = decorations.length;\n    // Index into decorations after the last decoration which ends at or before sourceIndex.\n    var decorationIndex = 0;\n  \n    // Simplify decorations.\n    var decPos = 0;\n    for (var i = 0; i < nDecorations;) {\n      // Skip over any zero-length decorations.\n      var startPos = decorations[i];\n      var start = i;\n      while (start + 2 < nDecorations && decorations[start + 2] === startPos) {\n        start += 2;\n      }\n      // Conflate all adjacent decorations that use the same style.\n      var startDec = decorations[start + 1];\n      var end = start + 2;\n    ";
"  while (end + 2 <= nDecorations\n             && (decorations[end + 1] === startDec\n                 || decorations[end] === decorations[end + 2])) {\n        end += 2;\n      }\n      decorations[decPos++] = startPos;\n      decorations[decPos++] = startDec;\n      i = end;\n    }\n  \n    // Strip any zero-length decoration at the end.\n    if (decPos && decorations[decPos - 2] === sourceLength) { decPos -= 2; }\n    nDecorations = decorations.length = decPos;\n  \n    var decoration = null;\n    while (spanIndex < nSpans) {\n      var spanStart = spans[spanIndex];\n      var spanEnd = spans[spanIndex + 2] || sourceLength;\n  \n      var decStart = decorations[decorationIndex];\n      var decEnd = decorations[decorationIndex + 2] || sourceLength;\n  \n      var end = Math.min(spanEnd, decEnd);\n  \n      var textNode = spans[spanIndex + 1];\n      if (textNode.nodeType !== 1) {  // Don't muck with <BR>s or <LI>s\n        var styledText = source.substring(sourceIndex, end);\n        // This may seem bizarre, and it is.  Emitting LF on IE causes the\n        // code to display with spaces instead of line breaks.\n        // Emitting Windows standard issue linebreaks (CRLF) causes a blank\n        // space to appear at the beginning of every line but the first.\n        // Emitting an old Mac OS 9 line separator makes everything spiffy.\n        if (isIE) { styledText = styledText.replace(newlineRe, '\\r'); }\n        textNode.nodeValue = styledText;\n        var document = textNode.ownerDocument;\n        var span = document.createElement('SPAN');\n        span.className = decorations[decorationIndex + 1];\n        var parentNode = textNode.parentNode;\n        parentNode.replaceChild(span, textNode);\n        span.appendChild(textNode);\n        if (sourceIndex < spanEnd) {  // Split off a text node.\n          spans[spanIndex + 1] = textNode\n              // TODO: Possibly optimize by using '' if there's no flicker.\n              = document.createTextNode(source.substring(end, spanEnd));\n          parentNode.insertBefore(textNode, span.nextSibling);\n        }\n      }\n  \n      sourceIndex = end;\n  \n      if (sourceIndex >= spanEnd) {\n        spanIndex += 2;\n      }\n      if (sourceIndex >= decEnd) {\n        decorationIndex += 2;\n      }\n    }\n  }\n\n\n  /** Maps language-specific file extensions to handlers. */\n  var langHandlerRegistry = {};\n  /** Register a language handler for the given file extensions.\n    * @param {function (Object)} handler a function from source code to a list\n    *      of decorations.  Takes a single argument job which describes the\n    *      state of the computation.   The single parameter has the form\n    *      {@code {\n    *        source: {string} as plain text.\n    *        decorations: {Array.<number|string>} an array of style classes\n    *                     preceded by the position at which they start in\n    *                     job.source in order.\n    *                     The language handler should assigned this field.\n    *        basePos: {int} the position of source in the larger source chunk.\n    *                 All positions in the output decorations array are relative\n    *                 to the larger source chunk.\n    *      } }\n    * @param {Array.<string>} fileExtensions\n    */\n  function registerLangHandler(handler, fileExtensions) {\n    for (var i = fileExtensions.length; --i >= 0;) {\n      var ext = fileExtensions[i];\n      if (!langHandlerRegistry.hasOwnProperty(ext)) {\n        langHandlerRegistry[ext] = handler;\n      } else if ('console' in window) {\n        console['warn']('cannot override language handler %s', ext);\n      }\n    }\n  }\n  function langHandlerForExtension(extension, source) {\n    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n      // Treat it as markup if the first non whitespace character is a < and\n      // the last non-whitespace character is a >.\n      extension = /^\\s*</.test(source)\n          ? 'default-markup'\n          : 'default-code';\n    }\n    return langHandlerRegistry[extension];\n  }\n  registerLangHandler(decorateSource, ['default-code']);\n  registerLa";
"ngHandler(\n      createSimpleLexer(\n          [],\n          [\n           [PR_PLAIN,       /^[^<?]+/],\n           [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\n           [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n           // Unescaped content in an unknown language\n           ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\n           ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\n           [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\n           ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n           // Unescaped content in javascript.  (Or possibly vbscript).\n           ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n           // Contains unescaped stylesheet content\n           ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\n           ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\n          ]),\n      ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\n  registerLangHandler(\n      createSimpleLexer(\n          [\n           [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\n           [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\n           ],\n          [\n           [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\n           [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\n           ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\n           [PR_PUNCTUATION,  /^[=<>\\/]+/],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\n           ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\n           ]),\n      ['in.tag']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CPP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true\n        }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': 'null true false'\n        }), ['json']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CSHARP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'verbatimStrings': true\n        }), ['cs']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JAVA_KEYWORDS,\n          'cStyleComments': true\n        }), ['java']);\n  registerLangHandler(sourceDecorator({\n          'keywords': SH_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true\n        }), ['bsh', 'csh', 'sh']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PYTHON_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'tripleQuotedStrings': true\n        }), ['cv', 'py']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PERL_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': true\n        }), ['perl', 'pl', 'pm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': RUBY_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': true\n        }), ['rb']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JSCRIPT_KEYWORDS,\n          'cStyleComments': true,\n          'regexLiterals': true\n        }), ['js']);\n  registerLangHandler(sourceDecorator({\n          'keywords': COFFEE_KEYWORDS,\n          'hashComments': 3,  // ### style block comments\n          'cStyleComments': true,\n          'multilineStrings': true,\n          'tripleQuotedStrings': true,\n          'regexLiterals': true\n        }), ['coffee']);\n  registerLangHandler(createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\n\n  function applyDecorator(job) {\n    var opt_langExtension = job.langExtension;\n\n    try {\n      // Extract tags, and convert the source code to plain text.\n      var sourceAndSpans = extractSourceSpans(job.sourceNode);\n      /** ";
"Plain text. @type {string} */\n      var source = sourceAndSpans.source;\n      job.source = source;\n      job.spans = sourceAndSpans.spans;\n      job.basePos = 0;\n\n      // Apply the appropriate language handler\n      langHandlerForExtension(opt_langExtension, source)(job);\n\n      // Integrate the decorations and tags back into the source code,\n      // modifying the sourceNode in place.\n      recombineTagsAndDecorations(job);\n    } catch (e) {\n      if ('console' in window) {\n        console['log'](e && e['stack'] ? e['stack'] : e);\n      }\n    }\n  }\n\n  /**\n   * @param sourceCodeHtml {string} The HTML to pretty print.\n   * @param opt_langExtension {string} The language name to use.\n   *     Typically, a filename extension like 'cpp' or 'java'.\n   * @param opt_numberLines {number|boolean} True to number lines,\n   *     or the 1-indexed number of the first line in sourceCodeHtml.\n   */\n  function prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n    var container = document.createElement('PRE');\n    // This could cause images to load and onload listeners to fire.\n    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\n    // We assume that the inner HTML is from a trusted source.\n    container.innerHTML = sourceCodeHtml;\n    if (opt_numberLines) {\n      numberLines(container, opt_numberLines);\n    }\n\n    var job = {\n      langExtension: opt_langExtension,\n      numberLines: opt_numberLines,\n      sourceNode: container\n    };\n    applyDecorator(job);\n    return container.innerHTML;\n  }\n\n  function prettyPrint(opt_whenDone) {\n    function byTagName(tn) { return document.getElementsByTagName(tn); }\n    // fetch a list of nodes to rewrite\n    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\n    var elements = [];\n    for (var i = 0; i < codeSegments.length; ++i) {\n      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n        elements.push(codeSegments[i][j]);\n      }\n    }\n    codeSegments = null;\n\n    var clock = Date;\n    if (!clock['now']) {\n      clock = { 'now': function () { return (new Date).getTime(); } };\n    }\n\n    // The loop is broken into a series of continuations to make sure that we\n    // don't make the browser unresponsive when rewriting a large page.\n    var k = 0;\n    var prettyPrintingJob;\n\n    function doWork() {\n      var endTime = (window['PR_SHOULD_USE_CONTINUATION'] ?\n                     clock.now() + 250 /* ms */ :\n                     Infinity);\n      for (; k < elements.length && clock.now() < endTime; k++) {\n        var cs = elements[k];\n        if (cs.className && cs.className.indexOf('prettyprint') >= 0) {\n          // If the classes includes a language extensions, use it.\n          // Language extensions can be specified like\n          //     <pre class=\"prettyprint lang-cpp\">\n          // the language extension \"cpp\" is used to find a language handler as\n          // passed to PR.registerLangHandler.\n          var langExtension = cs.className.match(/\\blang-(\\w+)\\b/);\n          if (langExtension) { langExtension = langExtension[1]; }\n\n          // make sure this is not nested in an already prettified element\n          var nested = false;\n          for (var p = cs.parentNode; p; p = p.parentNode) {\n            if ((p.tagName === 'pre' || p.tagName === 'code' ||\n                 p.tagName === 'xmp') &&\n                p.className && p.className.indexOf('prettyprint') >= 0) {\n              nested = true;\n              break;\n            }\n          }\n          if (!nested) {\n            // Look for a class like linenums or linenums:<n> where <n> is the\n            // 1-indexed number of the first line.\n            var lineNums = cs.className.match(/\\blinenums\\b(?::(\\d+))?/);\n            lineNums = lineNums\n                  ? lineNums[1] && lineNums[1].length ? +lineNums[1] : true\n                  : false;\n            if (lineNums) { numberLines(cs, lineNums); }\n\n            // do the pretty printing\n            prettyPrintingJob = {\n              langExtension: langExtension,\n              sourceNode: cs,\n              numberLines: l";
"ineNums\n            };\n            applyDecorator(prettyPrintingJob);\n          }\n        }\n      }\n      if (k < elements.length) {\n        // finish up in a continuation\n        setTimeout(doWork, 250);\n      } else if (opt_whenDone) {\n        opt_whenDone();\n      }\n    }\n\n    doWork();\n  }\n\n  window['prettyPrintOne'] = prettyPrintOne;\n  window['prettyPrint'] = prettyPrint;\n  window['PR'] = {\n        'createSimpleLexer': createSimpleLexer,\n        'registerLangHandler': registerLangHandler,\n        'sourceDecorator': sourceDecorator,\n        'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\n        'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\n        'PR_COMMENT': PR_COMMENT,\n        'PR_DECLARATION': PR_DECLARATION,\n        'PR_KEYWORD': PR_KEYWORD,\n        'PR_LITERAL': PR_LITERAL,\n        'PR_NOCODE': PR_NOCODE,\n        'PR_PLAIN': PR_PLAIN,\n        'PR_PUNCTUATION': PR_PUNCTUATION,\n        'PR_SOURCE': PR_SOURCE,\n        'PR_STRING': PR_STRING,\n        'PR_TAG': PR_TAG,\n        'PR_TYPE': PR_TYPE\n      };\n})();\n" ]
 | "slides.js" | "/slides.js" -> Some ["/*\n  Google HTML5 slides template\n\n  Authors: Luke Mah\195\131\194\169 (code)\n           Marcin Wichary (code and design)\n\n           Dominic Mazzoni (browser compatibility)\n           Charles Chen (ChromeVox support)\n\n  URL: http://code.google.com/p/html5slides/\n*/\n\nvar PERMANENT_URL_PREFIX = '/';\n\nvar SLIDE_CLASSES = ['far-past', 'past', 'current', 'next', 'far-next'];\n\nvar PM_TOUCH_SENSITIVITY = 15;\n\nvar curSlide;\n\n/* ---------------------------------------------------------------------- */\n/* classList polyfill by Eli Grey \n * (http://purl.eligrey.com/github/classList.js/blob/master/classList.js) */\n\nif (typeof document !== \"undefined\" && !(\"classList\" in document.createElement(\"a\"))) {\n\n(function (view) {\n\nvar\n    classListProp = \"classList\"\n  , protoProp = \"prototype\"\n  , elemCtrProto = (view.HTMLElement || view.Element)[protoProp]\n  , objCtr = Object\n    strTrim = String[protoProp].trim || function () {\n    return this.replace(/^\\s+|\\s+$/g, \"\");\n  }\n  , arrIndexOf = Array[protoProp].indexOf || function (item) {\n    for (var i = 0, len = this.length; i < len; i++) {\n      if (i in this && this[i] === item) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  // Vendors: please allow content code to instantiate DOMExceptions\n  , DOMEx = function (type, message) {\n    this.name = type;\n    this.code = DOMException[type];\n    this.message = message;\n  }\n  , checkTokenAndGetIndex = function (classList, token) {\n    if (token === \"\") {\n      throw new DOMEx(\n          \"SYNTAX_ERR\"\n        , \"An invalid or illegal string was specified\"\n      );\n    }\n    if (/\\s/.test(token)) {\n      throw new DOMEx(\n          \"INVALID_CHARACTER_ERR\"\n        , \"String contains an invalid character\"\n      );\n    }\n    return arrIndexOf.call(classList, token);\n  }\n  , ClassList = function (elem) {\n    var\n        trimmedClasses = strTrim.call(elem.className)\n      , classes = trimmedClasses ? trimmedClasses.split(/\\s+/) : []\n    ;\n    for (var i = 0, len = classes.length; i < len; i++) {\n      this.push(classes[i]);\n    }\n    this._updateClassName = function () {\n      elem.className = this.toString();\n    };\n  }\n  , classListProto = ClassList[protoProp] = []\n  , classListGetter = function () {\n    return new ClassList(this);\n  }\n;\n// Most DOMException implementations don't allow calling DOMException's toString()\n// on non-DOMExceptions. Error's toString() is sufficient here.\nDOMEx[protoProp] = Error[protoProp];\nclassListProto.item = function (i) {\n  return this[i] || null;\n};\nclassListProto.contains = function (token) {\n  token += \"\";\n  return checkTokenAndGetIndex(this, token) !== -1;\n};\nclassListProto.add = function (token) {\n  token += \"\";\n  if (checkTokenAndGetIndex(this, token) === -1) {\n    this.push(token);\n    this._updateClassName();\n  }\n};\nclassListProto.remove = function (token) {\n  token += \"\";\n  var index = checkTokenAndGetIndex(this, token);\n  if (index !== -1) {\n    this.splice(index, 1);\n    this._updateClassName();\n  }\n};\nclassListProto.toggle = function (token) {\n  token += \"\";\n  if (checkTokenAndGetIndex(this, token) === -1) {\n    this.add(token);\n  } else {\n    this.remove(token);\n  }\n};\nclassListProto.toString = function () {\n  return this.join(\" \");\n};\n\nif (objCtr.defineProperty) {\n  var classListPropDesc = {\n      get: classListGetter\n    , enumerable: true\n    , configurable: true\n  };\n  try {\n    objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n  } catch (ex) { // IE 8 doesn't support enumerable:true\n    if (ex.number === -0x7FF5EC54) {\n      classListPropDesc.enumerable = false;\n      objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n    }\n  }\n} else if (objCtr[protoProp].__defineGetter__) {\n  elemCtrProto.__defineGetter__(classListProp, classListGetter);\n}\n\n}(self));\n\n}\n/* ---------------------------------------------------------------------- */\n\n/* Slide movement */\n\nfunction getSlideEl(no) {\n  if ((no < 0) || (no >= slideEls.length)) { \n    return null;\n  } else {\n    return slideEls[no];\n  }\n};\n\nfunction updateSlideClass(slideNo, className) {\n  var el = getSlideEl(slideNo);\n  ";
"\n  if (!el) {\n    return;\n  }\n  \n  if (className) {\n    el.classList.add(className);\n  }\n    \n  for (var i in SLIDE_CLASSES) {\n    if (className != SLIDE_CLASSES[i]) {\n      el.classList.remove(SLIDE_CLASSES[i]);\n    }\n  }\n};\n\nfunction updateSlides() {\n  for (var i = 0; i < slideEls.length; i++) {\n    switch (i) {\n      case curSlide - 2:\n        updateSlideClass(i, 'far-past');\n        break;\n      case curSlide - 1:\n        updateSlideClass(i, 'past');\n        break;\n      case curSlide: \n        updateSlideClass(i, 'current');\n        break;\n      case curSlide + 1:\n        updateSlideClass(i, 'next');      \n        break;\n      case curSlide + 2:\n        updateSlideClass(i, 'far-next');      \n        break;\n      default:\n        updateSlideClass(i);\n        break;\n    }\n  }\n\n  triggerLeaveEvent(curSlide - 1);\n  triggerEnterEvent(curSlide);\n\n  window.setTimeout(function() {\n    // Hide after the slide\n    disableSlideFrames(curSlide - 2);\n  }, 301);\n\n  enableSlideFrames(curSlide - 1);\n  enableSlideFrames(curSlide + 2);\n  \n  if (isChromeVoxActive()) {\n    speakAndSyncToNode(slideEls[curSlide]);\n  }  \n\n  updateHash();\n};\n\nfunction buildNextItem() {\n  var toBuild  = slideEls[curSlide].querySelectorAll('.to-build');\n\n  if (!toBuild.length) {\n    return false;\n  }\n\n  toBuild[0].classList.remove('to-build', '');\n\n  if (isChromeVoxActive()) {\n    speakAndSyncToNode(toBuild[0]);\n  }\n\n  return true;\n};\n\nfunction prevSlide() {\n  if (curSlide > 0) {\n    curSlide--;\n\n    updateSlides();\n  }\n};\n\nfunction nextSlide() {\n  if (buildNextItem()) {\n    return;\n  }\n\n  if (curSlide < slideEls.length - 1) {\n    curSlide++;\n\n    updateSlides();\n  }\n};\n\n/* Slide events */\n\nfunction triggerEnterEvent(no) {\n  var el = getSlideEl(no);\n  if (!el) {\n    return;\n  }\n\n  var onEnter = el.getAttribute('onslideenter');\n  if (onEnter) {\n    new Function(onEnter).call(el);\n  }\n\n  var evt = document.createEvent('Event');\n  evt.initEvent('slideenter', true, true);\n  evt.slideNumber = no + 1; // Make it readable\n\n  el.dispatchEvent(evt);\n};\n\nfunction triggerLeaveEvent(no) {\n  var el = getSlideEl(no);\n  if (!el) {\n    return;\n  }\n\n  var onLeave = el.getAttribute('onslideleave');\n  if (onLeave) {\n    new Function(onLeave).call(el);\n  }\n\n  var evt = document.createEvent('Event');\n  evt.initEvent('slideleave', true, true);\n  evt.slideNumber = no + 1; // Make it readable\n  \n  el.dispatchEvent(evt);\n};\n\n/* Touch events */\n\nfunction handleTouchStart(event) {\n  if (event.touches.length == 1) {\n    touchDX = 0;\n    touchDY = 0;\n\n    touchStartX = event.touches[0].pageX;\n    touchStartY = event.touches[0].pageY;\n\n    document.body.addEventListener('touchmove', handleTouchMove, true);\n    document.body.addEventListener('touchend', handleTouchEnd, true);\n  }\n};\n\nfunction handleTouchMove(event) {\n  if (event.touches.length > 1) {\n    cancelTouch();\n  } else {\n    touchDX = event.touches[0].pageX - touchStartX;\n    touchDY = event.touches[0].pageY - touchStartY;\n  }\n};\n\nfunction handleTouchEnd(event) {\n  var dx = Math.abs(touchDX);\n  var dy = Math.abs(touchDY);\n\n  if ((dx > PM_TOUCH_SENSITIVITY) && (dy < (dx * 2 / 3))) {\n    if (touchDX > 0) {\n      prevSlide();\n    } else {\n      nextSlide();\n    }\n  }\n  \n  cancelTouch();\n};\n\nfunction cancelTouch() {\n  document.body.removeEventListener('touchmove', handleTouchMove, true);\n  document.body.removeEventListener('touchend', handleTouchEnd, true);  \n};\n\n/* Preloading frames */\n\nfunction disableSlideFrames(no) {\n  var el = getSlideEl(no);\n  if (!el) {\n    return;\n  }\n\n  var frames = el.getElementsByTagName('iframe');\n  for (var i = 0, frame; frame = frames[i]; i++) {\n    disableFrame(frame);\n  }\n};\n\nfunction enableSlideFrames(no) {\n  var el = getSlideEl(no);\n  if (!el) {\n    return;\n  }\n\n  var frames = el.getElementsByTagName('iframe');\n  for (var i = 0, frame; frame = frames[i]; i++) {\n    enableFrame(frame);\n  }\n};\n\nfunction disableFrame(frame) {\n  frame.src = 'about:blank';\n};\n\nfunction enableFrame(frame) {\n  var src = frame._src;\n\n  if (frame.src != src && src != 'about:blank') {\n    frame.src = src;\n  }\n};\n\nfunction set";
"upFrames() {\n  var frames = document.querySelectorAll('iframe');\n  for (var i = 0, frame; frame = frames[i]; i++) {\n    frame._src = frame.src;\n    disableFrame(frame);\n  }\n  \n  enableSlideFrames(curSlide);\n  enableSlideFrames(curSlide + 1);\n  enableSlideFrames(curSlide + 2);  \n};\n\nfunction setupInteraction() {\n  /* Clicking and tapping */\n  \n  var el = document.createElement('div');\n  el.className = 'slide-area';\n  el.id = 'prev-slide-area';  \n  el.addEventListener('click', prevSlide, false);\n  document.querySelector('section.slides').appendChild(el);\n\n  var el = document.createElement('div');\n  el.className = 'slide-area';\n  el.id = 'next-slide-area';  \n  el.addEventListener('click', nextSlide, false);\n  document.querySelector('section.slides').appendChild(el);  \n  \n  /* Swiping */\n  \n  document.body.addEventListener('touchstart', handleTouchStart, false);\n}\n\n/* ChromeVox support */\n\nfunction isChromeVoxActive() {\n  if (typeof(cvox) == 'undefined') {\n    return false;\n  } else {\n    return true;\n  }\n};\n\nfunction speakAndSyncToNode(node) {\n  if (!isChromeVoxActive()) {\n    return;\n  }\n  \n  cvox.ChromeVox.navigationManager.switchToStrategy(\n      cvox.ChromeVoxNavigationManager.STRATEGIES.LINEARDOM, 0, true);  \n  cvox.ChromeVox.navigationManager.syncToNode(node);\n  cvox.ChromeVoxUserCommands.finishNavCommand('');\n  var target = node;\n  while (target.firstChild) {\n    target = target.firstChild;\n  }\n  cvox.ChromeVox.navigationManager.syncToNode(target);\n};\n\nfunction speakNextItem() {\n  if (!isChromeVoxActive()) {\n    return;\n  }\n  \n  cvox.ChromeVox.navigationManager.switchToStrategy(\n      cvox.ChromeVoxNavigationManager.STRATEGIES.LINEARDOM, 0, true);\n  cvox.ChromeVox.navigationManager.next(true);\n  if (!cvox.DomUtil.isDescendantOfNode(\n      cvox.ChromeVox.navigationManager.getCurrentNode(), slideEls[curSlide])){\n    var target = slideEls[curSlide];\n    while (target.firstChild) {\n      target = target.firstChild;\n    }\n    cvox.ChromeVox.navigationManager.syncToNode(target);\n    cvox.ChromeVox.navigationManager.next(true);\n  }\n  cvox.ChromeVoxUserCommands.finishNavCommand('');\n};\n\nfunction speakPrevItem() {\n  if (!isChromeVoxActive()) {\n    return;\n  }\n  \n  cvox.ChromeVox.navigationManager.switchToStrategy(\n      cvox.ChromeVoxNavigationManager.STRATEGIES.LINEARDOM, 0, true);\n  cvox.ChromeVox.navigationManager.previous(true);\n  if (!cvox.DomUtil.isDescendantOfNode(\n      cvox.ChromeVox.navigationManager.getCurrentNode(), slideEls[curSlide])){\n    var target = slideEls[curSlide];\n    while (target.lastChild){\n      target = target.lastChild;\n    }\n    cvox.ChromeVox.navigationManager.syncToNode(target);\n    cvox.ChromeVox.navigationManager.previous(true);\n  }\n  cvox.ChromeVoxUserCommands.finishNavCommand('');\n};\n\n/* Hash functions */\n\nfunction getCurSlideFromHash() {\n  var slideNo = parseInt(location.hash.substr(1));\n\n  if (slideNo) {\n    curSlide = slideNo - 1;\n  } else {\n    curSlide = 0;\n  }\n};\n\nfunction updateHash() {\n  location.replace('#' + (curSlide + 1));\n};\n\n/* Event listeners */\n\nfunction handleBodyKeyDown(event) {\n  switch (event.keyCode) {\n    case 39: // right arrow\n    case 13: // Enter\n    case 32: // space\n    case 34: // PgDn\n      nextSlide();\n      event.preventDefault();\n      break;\n\n    case 37: // left arrow\n    case 8: // Backspace\n    case 33: // PgUp\n      prevSlide();\n      event.preventDefault();\n      break;\n\n    case 40: // down arrow\n      if (isChromeVoxActive()) {\n        speakNextItem();\n      } else {\n        nextSlide();\n      }\n      event.preventDefault();\n      break;\n\n    case 38: // up arrow\n      if (isChromeVoxActive()) {\n        speakPrevItem();\n      } else {\n        prevSlide();\n      }\n      event.preventDefault();\n      break;\n  }\n};\n\nfunction addEventListeners() {\n  document.addEventListener('keydown', handleBodyKeyDown, false);  \n};\n\n/* Initialization */\n\nfunction addPrettify() {\n  var els = document.querySelectorAll('pre');\n  for (var i = 0, el; el = els[i]; i++) {\n    if (!el.classList.contains('noprettyprint')) {\n      el.classList.add('prettyprint');\n    }\n  }\n  \n  v";
"ar el = document.createElement('script');\n  el.type = 'text/javascript';\n  el.src = PERMANENT_URL_PREFIX + 'prettify.js';\n  el.onload = function() {\n    prettyPrint();\n  }\n  document.body.appendChild(el);\n};\n\nfunction addFontStyle() {\n  var el = document.createElement('link');\n  el.rel = 'stylesheet';\n  el.type = 'text/css';\n  el.href = 'http://fonts.googleapis.com/css?family=' +\n            'Open+Sans:regular,semibold,italic,italicsemibold|Droid+Sans+Mono';\n\n  document.body.appendChild(el);\n};\n\nfunction addGeneralStyle() {\n  var el = document.createElement('link');\n  el.rel = 'stylesheet';\n  el.type = 'text/css';\n  el.href = PERMANENT_URL_PREFIX + 'styles.css';\n  document.body.appendChild(el);\n  \n  var el = document.createElement('meta');\n  el.name = 'viewport';\n  el.content = 'width=1100,height=750';\n  document.querySelector('head').appendChild(el);\n  \n  var el = document.createElement('meta');\n  el.name = 'apple-mobile-web-app-capable';\n  el.content = 'yes';\n  document.querySelector('head').appendChild(el);\n};\n\nfunction makeBuildLists() {\n  for (var i = curSlide, slide; slide = slideEls[i]; i++) {\n    var items = slide.querySelectorAll('.build > *');\n    for (var j = 0, item; item = items[j]; j++) {\n      if (item.classList) {\n        item.classList.add('to-build');\n      }\n    }\n  }\n};\n\nfunction handleDomLoaded() {\n  slideEls = document.querySelectorAll('section.slides > article');\n\n  setupFrames();\n\n  addFontStyle();\n  addGeneralStyle();\n  addPrettify();\n  addEventListeners();\n\n  updateSlides();\n\n  setupInteraction();\n  makeBuildLists();\n\n  document.body.classList.add('loaded');\n};\n\nfunction initialize() {\n  getCurSlideFromHash();\n\n  if (window['_DEBUG']) {\n    PERMANENT_URL_PREFIX = '../';\n  }\n\n  if (window['_DCL']) {\n    handleDomLoaded();\n  } else {\n    document.addEventListener('DOMContentLoaded', handleDomLoaded, false);\n  }\n}\n\n// If ?debug exists then load the script relative instead of absolute\nif (!window['_DEBUG'] && document.location.href.indexOf('?debug') !== -1) {\n  document.addEventListener('DOMContentLoaded', function() {\n    // Avoid missing the DomContentLoaded event\n    window['_DCL'] = true\n  }, false);\n\n  window['_DEBUG'] = true;\n  var script = document.createElement('script');\n  script.type = 'text/javascript';\n  script.src = '../slides.js';\n  var s = document.getElementsByTagName('script')[0];\n  s.parentNode.insertBefore(script, s);\n\n  // Remove this script\n  s.parentNode.removeChild(s);\n} else {\n  initialize();\n}\n" ]
 | "styles.css" | "/styles.css" -> Some ["/*\n  Google HTML5 slides template\n\n  Authors: Luke Mah\195\169 (code)\n           Marcin Wichary (code and design)\n           \n           Dominic Mazzoni (browser compatibility)\n           Charles Chen (ChromeVox support)\n\n  URL: http://code.google.com/p/html5slides/\n*/\n\n/* Framework */\n\nhtml {\n  height: 100%;\n}\n\nbody {\n  margin: 0;\n  padding: 0;\n\n  display: block !important;\n\n  height: 100%;\n  min-height: 740px;\n  \n  overflow-x: hidden;\n  overflow-y: auto;\n\n  background: rgb(215, 215, 215);\n  background: -o-radial-gradient(rgb(240, 240, 240), rgb(190, 190, 190));\n  background: -moz-radial-gradient(rgb(240, 240, 240), rgb(190, 190, 190));\n  background: -webkit-radial-gradient(rgb(240, 240, 240), rgb(190, 190, 190));\n  background: -webkit-gradient(radial, 50% 50%, 0, 50% 50%, 500, from(rgb(240, 240, 240)), to(rgb(190, 190, 190)));\n\n  -webkit-font-smoothing: antialiased;\n}\n\n.slides {\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  \n  position: absolute;\n\n  -webkit-transform: translate3d(0, 0, 0);\n}\n\n.slides > article {\n  display: block;\n\n  position: absolute;\n  overflow: hidden;\n\n  width: 900px;\n  height: 700px;\n\n  left: 50%;\n  top: 50%;\n\n  margin-left: -450px;\n  margin-top: -350px;\n  \n  padding: 40px 60px;\n\n  box-sizing: border-box;\n  -o-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n\n  border-radius: 10px;\n  -o-border-radius: 10px;\n  -moz-border-radius: 10px;\n  -webkit-border-radius: 10px;\n\n  background-color: white;\n\n  box-shadow: 0 2px 6px rgba(0, 0, 0, .1);\n  border: 1px solid rgba(0, 0, 0, .3);\n\n}\n.slides.layout-widescreen > article {\n  margin-left: -550px;\n  width: 1100px;\n}\n.slides.layout-faux-widescreen > article {\n  margin-left: -550px;\n  width: 1100px;\n  \n  padding: 40px 160px;\n}\n\n.slides.template-default > article:not(.nobackground):not(.biglogo) {\n  background: url(images/google-logo-small.png) 710px 625px no-repeat;  \n  \n  background-color: white;  \n} \n\n.slides.template-io2011 > article:not(.nobackground):not(.biglogo) {\n  background: url(images/colorbar.png) 0 600px repeat-x,\n              url(images/googleio-logo.png) 640px 625px no-repeat;\n\n  background-size: 100%, 225px;  \n\n  background-color: white;  \n}\n.slides.layout-widescreen > article:not(.nobackground):not(.biglogo),\n.slides.layout-faux-widescreen > article:not(.nobackground):not(.biglogo) {\n  background-position-x: 0, 840px;\n}\n\n/* Clickable/tappable areas */\n\n.slide-area {\n  z-index: 1000;\n\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 150px;\n  height: 700px;  \n\n  left: 50%;\n  top: 50%;\n\n  cursor: pointer;  \n  margin-top: -350px;  \n  \n  tap-highlight-color: transparent;\n  -o-tap-highlight-color: transparent;\n  -moz-tap-highlight-color: transparent;\n  -webkit-tap-highlight-color: transparent;\n}\n#prev-slide-area {\n  margin-left: -550px;\n}\n#next-slide-area {\n  margin-left: 400px;\n}\n.slides.layout-widescreen #prev-slide-area,\n.slides.layout-faux-widescreen #prev-slide-area {\n  margin-left: -650px;\n}\n.slides.layout-widescreen #next-slide-area,\n.slides.layout-faux-widescreen #next-slide-area {\n  margin-left: 500px;\n}\n\n/* Slide styles */\n\n.slides.template-default article.biglogo {\n  background: white url(images/google-logo.png) 50% 50% no-repeat;\n}\n\n.slides.template-io2011 article.biglogo {\n  background: white url(images/googleio-logo.png) 50% 50% no-repeat;\n\n  background-size: 600px;\n}\n\n/* Slides */\n\n.slides > article {\n  display: none;\n}\n.slides > article.far-past {\n  display: block;\n  transform: translate(-2040px);\n  -o-transform: translate(-2040px);\n  -moz-transform: translate(-2040px);\n  -webkit-transform: translate3d(-2040px, 0, 0);\n}\n.slides > article.past {\n  display: block;\n  transform: translate(-1020px);\n  -o-transform: translate(-1020px);\n  -moz-transform: translate(-1020px);\n  -webkit-transform: translate3d(-1020px, 0, 0);\n}\n.slides > article.current {\n  display: block;\n  transform: translate(0);\n  -o-transform: translate(0);\n  -moz-transform: translate(0);\n  -webkit-transform: translate3d(0, 0, 0);\n}\n.slides > article.next {\n  display: block;\n  transform: translate(1020px);\n  -o-transform: trans";
"late(1020px);\n  -moz-transform: translate(1020px);\n  -webkit-transform: translate3d(1020px, 0, 0);\n}\n.slides > article.far-next {\n  display: block;\n  transform: translate(2040px);\n  -o-transform: translate(2040px);\n  -moz-transform: translate(2040px);\n  -webkit-transform: translate3d(2040px, 0, 0);\n}\n\n.slides.layout-widescreen > article.far-past,\n.slides.layout-faux-widescreen > article.far-past {\n  display: block;\n  transform: translate(-2260px);\n  -o-transform: translate(-2260px);\n  -moz-transform: translate(-2260px);\n  -webkit-transform: translate3d(-2260px, 0, 0);\n}\n.slides.layout-widescreen > article.past,\n.slides.layout-faux-widescreen > article.past {\n  display: block;\n  transform: translate(-1130px);\n  -o-transform: translate(-1130px);\n  -moz-transform: translate(-1130px);\n  -webkit-transform: translate3d(-1130px, 0, 0);\n}\n.slides.layout-widescreen > article.current,\n.slides.layout-faux-widescreen > article.current {\n  display: block;\n  transform: translate(0);\n  -o-transform: translate(0);\n  -moz-transform: translate(0);\n  -webkit-transform: translate3d(0, 0, 0);\n}\n.slides.layout-widescreen > article.next,\n.slides.layout-faux-widescreen > article.next {\n  display: block;\n  transform: translate(1130px);\n  -o-transform: translate(1130px);\n  -moz-transform: translate(1130px);\n  -webkit-transform: translate3d(1130px, 0, 0);\n}\n.slides.layout-widescreen > article.far-next,\n.slides.layout-faux-widescreen > article.far-next {\n  display: block;\n  transform: translate(2260px);\n  -o-transform: translate(2260px);\n  -moz-transform: translate(2260px);\n  -webkit-transform: translate3d(2260px, 0, 0);\n}\n\n/* Styles for slides */\n\n.slides > article {\n  font-family: 'Open Sans', Arial, sans-serif;\n\n  color: rgb(102, 102, 102);\n  text-shadow: 0 1px 1px rgba(0, 0, 0, .1);\n\n  font-size: 27px;\n  line-height: 36px;\n\n  letter-spacing: -1px;\n}\n\nb {\n  font-weight: 600;\n}\n\n.blue {\n  color: rgb(0, 102, 204);\n}\n.yellow {\n  color: rgb(255, 211, 25);\n}\n.green {\n  color: rgb(0, 138, 53);\n}\n.red {\n  color: rgb(255, 0, 0);\n}\n.black {\n  color: black;\n}\n.white {\n  color: white;\n}\n\na {\n  color: rgb(0, 102, 204);\n}\na:visited {\n  color: rgba(0, 102, 204, .75);\n}\na:hover {\n  color: black;\n}\n\np {\n  margin: 0;\n  padding: 0;\n\n  margin-top: 20px;\n}\np:first-child {\n  margin-top: 0;\n}\n\nh1 {\n  font-size: 60px;\n  line-height: 60px;\n\n  padding: 0;\n  margin: 0;\n  margin-top: 200px;\n  padding-right: 40px;\n\n  font-weight: 600;\n\n  letter-spacing: -3px;\n\n  color: rgb(51, 51, 51);\n}\n\nh2 {\n  font-size: 45px;\n  line-height: 45px;\n\n  position: absolute;\n  bottom: 150px;\n\n  padding: 0;\n  margin: 0;\n  padding-right: 40px;\n\n  font-weight: 600;\n\n  letter-spacing: -2px;\n\n  color: rgb(51, 51, 51);\n}\n\nh3 {\n  font-size: 30px;\n  line-height: 36px;\n\n  padding: 0;\n  margin: 0;\n  padding-right: 40px;\n\n  font-weight: 600;\n\n  letter-spacing: -1px;\n\n  color: rgb(51, 51, 51);\n}\n\narticle.fill h3 {\n  background: rgba(255, 255, 255, .75);\n  padding-top: .2em;\n  padding-bottom: .3em;\n  margin-top: -.2em;\n  margin-left: -60px;\n  padding-left: 60px;\n  margin-right: -60px;\n  padding-right: 60px;\n}\n\nul {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n\n  margin-top: 40px;\n\n  margin-left: .75em;\n}\nul:first-child {\n  margin-top: 0;\n}\nul ul {\n  margin-top: .5em;\n}\nli {\n  padding: 0;\n  margin: 0;\n\n  margin-bottom: .5em;\n}\nli::before {\n  content: '\194\183';\n\n  width: .75em;\n  margin-left: -.75em;\n\n  position: absolute;\n}\n\npre {\n  font-family: 'Droid Sans Mono', 'Courier New', monospace;\n\n  font-size: 20px;\n  line-height: 28px;\n  padding: 5px 10px;\n  \n  letter-spacing: -1px;\n\n  margin-top: 40px;\n  margin-bottom: 40px;\n\n  color: black;\n  background: rgb(240, 240, 240);\n  border: 1px solid rgb(224, 224, 224);\n  box-shadow: inset 0 2px 6px rgba(0, 0, 0, .1);\n  \n  overflow: hidden;\n}\n\ntt {\n  font-color: #000050;\n}\n\ncode {\n  font-size: 95%;\n  font-family: 'Droid Sans Mono', 'Courier New', monospace;\n\n  color: black;\n}\n\niframe {\n  width: 100%;\n\n  height: 620px;\n\n  background: white;\n  border: 1px solid rgb(192, 192, 192);\n  margin: -1px;\n  /*box-shadow: inset 0 2px 6px rgba(0, 0, 0, .1);*/\n}\n\nh3 + iframe {\n  mar";
"gin-top: 40px;\n  height: 540px;\n}\n\narticle.fill iframe {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n\n  border: 0;\n  margin: 0;\n\n  border-radius: 10px;\n  -o-border-radius: 10px;\n  -moz-border-radius: 10px;\n  -webkit-border-radius: 10px;\n\n  z-index: -1;\n}\n\narticle object {\n  position: absolute;\n  left: 0;\n  top: 0;\n  min-width: 900px;\n  min-height: 600px;\n\n  border-radius: 10px;\n  -o-border-radius: 10px;\n  -moz-border-radius: 10px;\n  -webkit-border-radius: 10px;\n\n  z-index: -1;\n}\n\n\narticle.fill object {\n  position: absolute;\n  left: 0;\n  top: 0;\n  min-width: 900px;\n  min-height: 600px;\n\n  border-radius: 10px;\n  -o-border-radius: 10px;\n  -moz-border-radius: 10px;\n  -webkit-border-radius: 10px;\n\n  z-index: -1;\n}\n\narticle.fill img {\n  position: absolute;\n  left: 0;\n  top: 0;\n  min-width: 100%;\n  min-height: 100%;\n\n  border-radius: 10px;\n  -o-border-radius: 10px;\n  -moz-border-radius: 10px;\n  -webkit-border-radius: 10px;\n\n  z-index: -1;\n}\n\nimg.centered {\n  margin: 0 auto;\n  display: block;\n}\n\nobject.centered {\n  margin: 0 auto;\n  display: block;\n}\n\ntable {\n  width: 100%;\n  border-collapse: collapse;\n  margin-top: 40px;\n}\nth {\n  font-weight: 600;\n  text-align: left;\n}\ntd,\nth {\n  border: 1px solid rgb(224, 224, 224);\n  padding: 5px 10px;\n  vertical-align: top;\n}\n\n.source {\n  position: absolute;\n  left: 60px;\n  top: 644px;\n  padding-right: 175px;\n  \n  font-size: 15px;\n  letter-spacing: 0;  \n  line-height: 18px;\n}\n\nq {\n  display: block;\n  font-size: 60px;\n  line-height: 72px;\n  \n  margin-left: 20px;\n  \n  margin-top: 100px;\n  margin-right: 150px;    \n}\nq::before {\n  content: '\226\128\156';\n  \n  position: absolute;\n  display: inline-block;\n  margin-left: -2.1em;\n  width: 2em;\n  text-align: right;\n  \n  font-size: 90px;\n  color: rgb(192, 192, 192);\n}\nq::after {\n  content: '\226\128\157';\n\n  position: absolute;  \n  margin-left: .1em;\n\n  font-size: 90px;\n  color: rgb(192, 192, 192);  \n}\ndiv.author {\n  text-align: right;  \n  font-size: 40px;\n  \n  margin-top: 20px;\n  margin-right: 150px;    \n}\ndiv.author::before {\n  content: '\226\128\148';\n}\n\n/* Size variants */\n\narticle.smaller p,\narticle.smaller ul {\n  font-size: 20px;\n  line-height: 24px;\n  letter-spacing: 0;\n}\narticle.smaller table {\n  font-size: 20px;\n  line-height: 24px;\n  letter-spacing: 0;\n}\narticle.smaller pre {\n  font-size: 15px;\n  line-height: 20px;\n  letter-spacing: 0;\n}\narticle.smaller q {\n  font-size: 40px;\n  line-height: 48px;\n}\narticle.smaller q::before,\narticle.smaller q::after {\n  font-size: 60px;\n}\n\n/* Builds */\n\n.build > * {\n  transition: opacity 0.5s ease-in-out 0.2s;\n  -o-transition: opacity 0.5s ease-in-out 0.2s;\n  -moz-transition: opacity 0.5s ease-in-out 0.2s;\n  -webkit-transition: opacity 0.5s ease-in-out 0.2s;\n}\n\n.to-build {\n  opacity: 0;\n}\n\n/* Pretty print */\n\n.prettyprint .str, /* string content */\n.prettyprint .atv { /* a markup attribute value */\n  color: rgb(0, 138, 53); \n}  \n.prettyprint .kwd, /* a keyword */\n.prettyprint .tag { /* a markup tag name */\n  color: rgb(0, 102, 204);\n}\n.prettyprint .com { /* a comment */\n  color: rgb(127, 127, 127); \n  font-style: italic; \n}  \n.prettyprint .lit { /* a literal value */\n  color: rgb(127, 0, 0);\n}  \n.prettyprint .pun, /* punctuation, lisp open bracket, lisp close bracket */\n.prettyprint .opn, \n.prettyprint .clo { \n  color: rgb(127, 127, 127); \n}\n.prettyprint .typ, /* a type name */\n.prettyprint .atn, /* a markup attribute name */ \n.prettyprint .dec, \n.prettyprint .var { /* a declaration; a variable name */\n  color: rgb(127, 0, 127);\n}  \n" ]
 | _ -> None

let file_list = ["slides.js"; "prettify.js"; "styles.css";  ]
let size = function
 |"slides.js" |"/slides.js" -> Some 14772L
 |"prettify.js" |"/prettify.js" -> Some 54257L
 |"styles.css" |"/styles.css" -> Some 11706L
 |_ -> None

end

let name="static"

open Lwt

exception Error of string

let iter_s fn = Lwt_list.iter_s fn Internal.file_list

let size name = return (Internal.size name)

let read name =
  match Internal.file_chunks name with
  |None -> return None
  |Some c ->
     let chunks = ref c in
     return (Some (Lwt_stream.from (fun () ->
       match !chunks with
       |hd :: tl -> 
         chunks := tl;
         let pg = OS.Io_page.get () in
         let len = String.length hd in
         Cstruct.set_buffer hd 0 pg 0 len;
         return (Some (Cstruct.sub pg 0 len))
       |[] -> return None
     )))

let create vbd : OS.Devices.kv_ro Lwt.t =  
  return (object
    method iter_s fn = iter_s fn
    method read name = read name
    method size name = size name
  end)

let _ =
  let plug = Lwt_mvar.create_empty () in
  let unplug = Lwt_mvar.create_empty () in
  let provider = object(self)
    method id = name
    method plug = plug
    method unplug = unplug
    method create ~deps ~cfg id =
      Lwt.bind (create id) (fun kv ->
        let entry = OS.Devices.({
           provider=self;
           id=self#id;
           depends=[];
           node=KV_RO kv }) in
        return entry
      )
  end in
  OS.Devices.new_provider provider;
  OS.Main.at_enter (fun () -> Lwt_mvar.put plug {OS.Devices.p_id=name; p_dep_ids=[]; p_cfg=[]})

